<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mini-Nuke HD: Fixed & Contained</title>
    <style>
        body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; }
        canvas { background: #000; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="nukeCanvas"></canvas>

<script>
const canvas = document.getElementById('nukeCanvas');
const ctx = canvas.getContext('2d');

// --- HD MOBILE SETUP ---
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// These controls keep the effect small and at the bottom
const SCALE = 1.8; 
const POS_X = () => canvas.width / 2;
const POS_Y = () => canvas.height - 80;

class Particle {
    constructor(x, y, type, parent = null, customVel = null) {
        this.x = x; 
        this.y = y;
        this.originX = x;
        this.originY = y;
        this.type = type;
        this.parent = parent;
        this.life = 1.0;
        
        // Decay tuned for long life
        this.decay = (type === 'redPulse' ? 0.0035 : 0.007) + Math.random() * 0.01;
        this.size = Math.random() * 3 + 2;

        this.points = [];
        const sides = 5 + Math.floor(Math.random() * 3);
        for(let i=0; i<sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            const dist = 0.4 + Math.random() * 0.6;
            this.points.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist });
        }

        if (customVel) {
            this.vx = customVel.x;
            this.vy = customVel.y;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const force = Math.random() * 4;
            this.vx = Math.cos(angle) * force;
            this.vy = Math.sin(angle) * force;
        }
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        if (this.type === 'redPulse') {
            // PHASE 1: Billowing & Stepping Up
            if (this.life > 0.4) {
                this.vx *= 0.92; 
                this.vy *= 0.92;
                this.size += 0.14;
                // Move up with the center
                if (this.parent) this.y -= 0.7; 
            } 
            // PHASE 2: Faster Final Suction
            else {
                const targetY = this.parent ? this.parent.pulseY : this.y;
                const dx = -this.x;
                const dy = targetY - this.y;
                
                // Acceleration increases as life ends
                const pullPower = 0.15 + (0.5 * (1 - this.life));
                this.vx += dx * pullPower;
                this.vy += dy * pullPower;
                
                this.vx *= 0.6; this.vy *= 0.6;
                this.size *= 0.9;
                
                if (Math.abs(dx) < 2 && Math.abs(dy) < 2) this.life = 0;
                this.decay = 0.05;
            }
        } 
        else if (this.type === 'coreJet') {
            this.vy -= 0.18;
            this.vx *= 0.94;
            this.vy *= 0.94;
            if (this.y < -350) this.decay = 0.1;
        } 
        else if (this.type === 'smoke' || this.type === 'fire') {
            // --- TOROIDAL DISK CAP LOGIC ---
            const distFromCenter = Math.abs(this.x);
            const capHeight = -220; // Where the disk forms
            
            if (this.y < capHeight) {
                const maxRadius = 120; // Arbitrary diameter
                if (distFromCenter < maxRadius) {
                    this.vx += (this.x * 0.02); // Expand out
                    this.vy *= 0.92; // Slow down vertical
                } else {
                    this.vx -= (this.x * 0.08); // Hit the edge, pull back
                    this.vy += 0.5; // Sink back down
                }
            } else {
                this.vy -= 0.15; // Rise up the stem
            }
            this.vx *= 0.96;
            this.vy *= 0.96;
            if (this.type === 'fire') this.size += 0.15;
        }

        this.life -= this.decay;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.translate(this.x, this.y);

        let r, g, b, alpha = this.life;
        if (this.type === 'redPulse') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 20; b = 0;
        } else if (this.type === 'fire') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 110 * this.life; b = 20;
        } else {
            r = g = b = 80 * this.life; alpha *= 0.7;
        }

        ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
        ctx.beginPath();
        const s = this.size;
        this.points.forEach((p, i) => {
            if (i === 0) ctx.moveTo(p.x * s, p.y * s);
            else ctx.lineTo(p.x * s, p.y * s);
        });
        ctx.fill();
        ctx.restore();
    }
}

class Explosion {
    constructor() {
        this.particles = [];
        this.frame = 0;
        this.flash = 1.0;
        this.shockSize = 0;
        this.pulseY = -250; // Initial center
    }

    update() {
        this.frame++;
        this.flash *= 0.88;
        this.shockSize += 14;

        // Pulse Step Up
        if (this.frame > 95 && this.frame < 220) {
            this.pulseY -= 0.7; 
        }

        // Initial Blast
        if (this.frame < 12) {
            for(let i=0; i<15; i++) this.particles.push(new Particle(0, 0, 'plasma'));
        }

        // Core White Jet
        if (this.frame > 4 && this.frame < 85 && this.frame % 2 === 0) {
            this.particles.push(new Particle(0, 0, 'coreJet', null, {x: (Math.random()-0.5), y: -10}));
        }

        // Crimson Pulse
        if (this.frame === 95) {
            for(let i=0; i<280; i++) {
                const a = Math.random() * Math.PI * 2;
                const s = 3 + Math.random() * 6;
                this.particles.push(new Particle(0, this.pulseY, 'redPulse', this, {x: Math.cos(a)*s, y: Math.sin(a)*s}));
            }
        }
        
        // Spew from rising center
        if (this.frame > 100 && this.frame < 220 && this.frame % 4 === 0) {
            for(let i=0; i<4; i++) this.particles.push(new Particle(0, this.pulseY, 'redPulse', this));
        }

        // Stem & Mushroom Cap
        if (this.frame > 10 && this.frame < 250) {
            for(let i=0; i<4; i++) this.particles.push(new Particle((Math.random()-0.5)*15, -(this.frame * 1.5), 'fire'));
            if (this.frame > 40) {
                const capY = Math.max(-300, -(this.frame * 2.2));
                for(let i=0; i<6; i++) this.particles.push(new Particle((Math.random()-0.5)*50, capY, 'smoke'));
            }
        }

        this.particles.forEach((p, i) => {
            p.update();
            if (p.life <= 0) this.particles.splice(i, 1);
        });
    }

    draw(ctx) {
        // ELLIPSE SHOCKWAVE (Kept small and proportional)
        if (this.frame < 35) {
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.45 - this.frame/35})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(0, 0, this.shockSize, this.shockSize * 0.18, 0, 0, Math.PI * 2);
            ctx.stroke();
        }

        this.particles.sort((a,b) => a.type === 'smoke' ? -1 : 1);
        this.particles.forEach(p => p.draw(ctx));

        if (this.flash > 0.01) {
            ctx.fillStyle = `rgba(255,255,255,${this.flash})`;
            ctx.fillRect(-canvas.width, -canvas.height*2, canvas.width*2, canvas.height*2);
        }
    }
}

let nuke = new Explosion();
function loop() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    // Position the effect at bottom center and scale it
    ctx.translate(POS_X(), POS_Y());
    ctx.scale(SCALE, SCALE);

    nuke.update();
    nuke.draw(ctx);
    ctx.restore();

    if (nuke.frame > 550 && nuke.particles.length === 0) nuke = new Explosion();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
