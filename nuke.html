<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Responsive Mini-Nuke: Mobile Vertical</title>
    <style>
        body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; }
        canvas { background: #000; width: 100vw; height: 100vh; touch-action: none; }
    </style>
</head>
<body>
    <canvas id="nukeCanvas"></canvas>

<script>
const canvas = document.getElementById('nukeCanvas');
const ctx = canvas.getContext('2d');

// --- DYNAMIC RESIZING ---
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

class Particle {
    constructor(px, py, type, parent = null, customVel = null) {
        // All coordinates and velocities stored as percentages (0.0 - 1.0)
        this.px = px; 
        this.py = py;
        this.originPX = px;
        this.originPY = py;
        this.type = type;
        this.parent = parent;
        this.life = 1.0;
        
        // Dynamic Decay
        this.decay = (type === 'redPulse' ? 0.004 : 0.007) + Math.random() * 0.01;
        
        // Base size relative to screen width
        this.baseSize = 0.01 + Math.random() * 0.01;

        if (customVel) {
            this.pvx = customVel.x; 
            this.pvy = customVel.y;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const force = 0.002 + Math.random() * 0.005;
            this.pvx = Math.cos(angle) * force;
            this.pvy = Math.sin(angle) * force;
        }

        this.points = [];
        const sides = 5 + Math.floor(Math.random() * 3);
        for(let i=0; i<sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            this.points.push({ x: Math.cos(angle), y: Math.sin(angle) });
        }
    }

    update() {
        this.px += this.pvx;
        this.py += this.pvy;

        // --- THE CRIMSON PULSE: RISING & SNAPPING ---
        if (this.type === 'redPulse') {
            if (this.life > 0.45) {
                this.pvx *= 0.92;
                this.pvy *= 0.92;
                this.baseSize += 0.0005;
                // Inherit the rise from the parent center
                if (this.parent) this.py -= 0.0015; 
            } else {
                // SNAP-BACK to the center (which has risen)
                const targetPX = 0.5;
                const targetPY = this.parent ? this.parent.pulsePY : this.py;
                const dx = targetPX - this.px;
                const dy = targetPY - this.py;
                
                const pull = 0.15 + (0.4 * (1 - this.life));
                this.pvx += dx * pull;
                this.pvy += dy * pull;
                this.pvx *= 0.7; 
                this.pvy *= 0.7;
                this.baseSize *= 0.94;
                
                if (Math.abs(dx) < 0.005 && Math.abs(dy) < 0.005) this.life = 0;
                this.decay = 0.05;
            }
        } 
        else if (this.type === 'coreJet') {
            this.pvy -= 0.003;
            this.pvx *= 0.94;
            if (this.py < 0.15) this.decay = 0.1;
        } 
        else if (this.type === 'smoke' || this.type === 'fire') {
            const dx = this.px - 0.5;
            const dy = 0.9 - this.py; // Distance from ground

            // --- TOROIDAL DISK LOGIC ---
            if (dy > 0.35) { // When it hits the "Cap Zone"
                const maxRadius = 0.32; // Limit width to 32% of screen
                if (Math.abs(dx) < maxRadius) {
                    this.pvx += (dx * 0.003); // Push out
                    this.pvy *= 0.94; // Slow down vertical rise
                } else {
                    this.pvx -= (dx * 0.02); // Suck back to center
                    this.pvy += 0.002; // Sink to create the "roll"
                }
            } else {
                this.pvy -= 0.001; // Rise up the stem
            }
            this.pvx *= 0.98;
            this.pvy *= 0.98;
            if (this.type === 'fire') this.baseSize += 0.0004;
        }

        this.life -= this.decay;
    }

    draw() {
        if (this.life <= 0) return;
        
        // Convert normalized % back to current screen pixels
        const x = this.px * canvas.width;
        const y = this.py * canvas.height;
        const screenRef = Math.min(canvas.width, canvas.height);
        const size = this.baseSize * screenRef;

        ctx.save();
        ctx.translate(x, y);

        let r, g, b, alpha = this.life;
        if (this.type === 'redPulse') {
            ctx.globalCompositeOperation = 'lighter';
            r=255; g=20; b=0;
        } else if (this.type === 'fire') {
            ctx.globalCompositeOperation = 'lighter';
            r=255; g=120 * this.life; b=20;
        } else {
            r=g=b=85 * this.life; alpha *= 0.7;
        }

        ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
        ctx.beginPath();
        this.points.forEach((p, i) => {
            if (i === 0) ctx.moveTo(p.x * size, p.y * size);
            else ctx.lineTo(p.x * size, p.y * size);
        });
        ctx.fill();
        ctx.restore();
    }
}

class Explosion {
    constructor() {
        this.particles = [];
        this.frame = 0;
        this.flash = 1.0;
        this.shockSize = 0;
        this.pulsePY = 0.65; // Starting center Y (65% down)
    }

    update() {
        this.frame++;
        this.flash *= 0.9;
        this.shockSize += 0.015;

        // --- THE "STEP UP" ---
        // The center of the crimson effect rises over time
        if (this.frame > 95 && this.frame < 250) {
            this.pulsePY -= 0.0015; 
        }

        if (this.frame < 12) {
            for(let i=0; i<8; i++) this.particles.push(new Particle(0.5, 0.9, 'fire'));
        }

        if (this.frame > 5 && this.frame < 90 && this.frame % 2 === 0) {
            this.particles.push(new Particle(0.5, 0.9, 'coreJet', null, {x: (Math.random()-0.5)*0.002, y: -0.01}));
        }

        // CRIMSON PULSE SPAWN
        if (this.frame === 95) {
            for(let i=0; i<280; i++) {
                const a = Math.random() * Math.PI * 2;
                const s = 0.004 + Math.random() * 0.01;
                this.particles.push(new Particle(0.5, this.pulsePY, 'redPulse', this, {x:Math.cos(a)*s, y:Math.sin(a)*s}));
            }
        }
        
        // SPEW CENTER (Continuous red fountain)
        if (this.frame > 100 && this.frame < 220 && this.frame % 3 === 0) {
            for(let i=0; i<3; i++) {
                this.particles.push(new Particle(0.5, this.pulsePY, 'redPulse', this));
            }
        }

        // STEM & MUSHROOM CAP
        if (this.frame > 15 && this.frame < 280) {
            if (this.frame % 2 === 0) {
                // Rising fire/smoke
                this.particles.push(new Particle(0.5 + (Math.random()-0.5)*0.03, 0.9 - (this.frame*0.003), 'smoke'));
            }
        }

        this.particles.forEach((p, i) => {
            p.update();
            if (p.life <= 0) this.particles.splice(i, 1);
        });
    }

    draw() {
        // --- RESPONSIVE SHOCKWAVE ---
        if (this.frame < 40) {
            const rx = this.shockSize * canvas.width;
            const ry = this.shockSize * 0.2 * canvas.height;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.45 - this.frame/40})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(canvas.width*0.5, canvas.height*0.9, rx, ry, 0, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Draw particles (Sorted for smoke depth)
        this.particles.sort((a,b) => a.type === 'smoke' ? -1 : 1);
        this.particles.forEach(p => p.draw());

        if (this.flash > 0.01) {
            ctx.fillStyle = `rgba(255,255,255,${this.flash})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }
}

let nuke = new Explosion();
function loop() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    nuke.update();
    nuke.draw();
    if (nuke.frame > 550 && nuke.particles.length === 0) nuke = new Explosion();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
