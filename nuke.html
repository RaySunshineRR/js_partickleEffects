<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mini-Nuke: Crimson Pulse</title>
    <style>
        body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; }
        canvas { background: #000; }
    </style>
</head>
<body>
    <canvas id="nukeCanvas"></canvas>

<script>
const canvas = document.getElementById('nukeCanvas');
const ctx = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 700;
const origin = { x: canvas.width / 2, y: canvas.height - 100 };

class Particle {
    constructor(x, y, type, customVel = null) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.life = 1.0;
        this.decay = (type === 'plasma' ? 0.02 : (type === 'redPulse' ? 0.005 : 0.007)) + Math.random() * 0.01;
        this.size = Math.random() * 3 + 2;

        this.originX = x;
        this.originY = y;

        this.points = [];
        const sides = 5 + Math.floor(Math.random() * 3);
        for(let i=0; i<sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            const dist = 0.4 + Math.random() * 0.6;
            this.points.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist });
        }

        if (customVel) {
            this.vx = customVel.x;
            this.vy = customVel.y;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const force = Math.random() * 4;
            this.vx = Math.cos(angle) * force;
            this.vy = Math.sin(angle) * force;
        }

        this.rotation = Math.random() * Math.PI * 2;
        this.vRot = (Math.random() - 0.5) * 0.15;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.vRot;

        if (this.type === 'redPulse') {
            if (this.life > 0.55) {
                this.vx *= 0.91;
                this.vy *= 0.91;
                this.size += 0.14; // Billowing expansion
            } else {
                const dx = this.originX - this.x;
                const dy = this.originY - this.y;
                this.vx += dx * 0.16; // Aggressive suction
                this.vy += dy * 0.16;
                this.vx *= 0.70;
                this.vy *= 0.70;
                this.size *= 0.90;
                this.decay = 0.04; // Rapid expiration on snap-back
            }
        }
        else if (this.type === 'coreJet') {
            this.vy -= 0.14;
            this.vx *= 0.94;
            this.vy *= 0.94;
            if (this.y < origin.y - 420) this.decay = 0.08;
        } else if (this.type === 'fire' || this.type === 'plasma') {
            this.size += 0.16;
            this.vy -= 0.19;
            this.vx *= 0.96;
            this.vy *= 0.96;
        } else {
            this.vy -= 0.09;
            this.vx *= 0.96;
            this.vy *= 0.96;
        }

        const dx = this.x - origin.x;
        const dy = origin.y - this.y;
        if (dy > 240 && (this.type === 'smoke' || this.type === 'fire')) {
            this.vx += dx * 0.015;
            if (Math.abs(dx) > 85) this.vy += 0.25;
            this.size += 0.06;
        }

        this.life -= this.decay;
    }

    draw(ctx) {<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mini-Nuke: Crimson Pulse</title>
    <style>
        body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; }
        canvas { background: #000; }
    </style>
</head>
<body>
    <canvas id="nukeCanvas"></canvas>

<script>
const canvas = document.getElementById('nukeCanvas');
const ctx = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 700;
const origin = { x: canvas.width / 2, y: canvas.height - 100 };

class Particle {
    constructor(x, y, type, customVel = null) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.life = 1.0;
        this.decay = (type === 'plasma' ? 0.02 : (type === 'redPulse' ? 0.005 : 0.007)) + Math.random() * 0.01;
        this.size = Math.random() * 3 + 2;

        this.originX = x;
        this.originY = y;

        this.points = [];
        const sides = 5 + Math.floor(Math.random() * 3);
        for(let i=0; i<sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            const dist = 0.4 + Math.random() * 0.6;
            this.points.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist });
        }

        if (customVel) {
            this.vx = customVel.x;
            this.vy = customVel.y;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const force = Math.random() * 4;
            this.vx = Math.cos(angle) * force;
            this.vy = Math.sin(angle) * force;
        }

        this.rotation = Math.random() * Math.PI * 2;
        this.vRot = (Math.random() - 0.5) * 0.15;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.vRot;

        if (this.type === 'redPulse') {
            if (this.life > 0.55) {
                this.vx *= 0.91;
                this.vy *= 0.91;
                this.size += 0.14; // Billowing expansion
            } else {
                const dx = this.originX - this.x;
                const dy = this.originY - this.y;
                this.vx += dx * 0.16; // Aggressive suction
                this.vy += dy * 0.16;
                this.vx *= 0.70;
                this.vy *= 0.70;<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mini-Nuke: Crimson Pulse</title>
    <style>
        body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; }
        canvas { background: #000; }
    </style>
</head>
<body>
    <canvas id="nukeCanvas"></canvas>

<script>
const canvas = document.getElementById('nukeCanvas');
const ctx = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 700;
const origin = { x: canvas.width / 2, y: canvas.height - 100 };

class Particle {
    constructor(x, y, type, customVel = null) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.life = 1.0;
        this.decay = (type === 'plasma' ? 0.02 : (type === 'redPulse' ? 0.005 : 0.007)) + Math.random() * 0.01;
        this.size = Math.random() * 3 + 2;

        this.originX = x;
        this.originY = y;

        this.points = [];
        const sides = 5 + Math.floor(Math.random() * 3);
        for(let i=0; i<sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            const dist = 0.4 + Math.random() * 0.6;
            this.points.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist });
        }

        if (customVel) {
            this.vx = customVel.x;
            this.vy = customVel.y;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const force = Math.random() * 4;
            this.vx = Math.cos(angle) * force;
            this.vy = Math.sin(angle) * force;
        }

        this.rotation = Math.random() * Math.PI * 2;
        this.vRot = (Math.random() - 0.5) * 0.15;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.vRot;

        if (this.type === 'redPulse') {
            if (this.life > 0.55) {
                this.vx *= 0.91;
                this.vy *= 0.91;
                this.size += 0.14; // Billowing expansion
            } else {
                const dx = this.originX - this.x;
                const dy = this.originY - this.y;
                this.vx += dx * 0.16; // Aggressive suction
                this.vy += dy * 0.16;
                this.vx *= 0.70;
                this.vy *= 0.70;
                this.size *= 0.90;
                this.decay = 0.04; // Rapid expiration on snap-back
            }
        }
        else if (this.type === 'coreJet') {
            this.vy -= 0.14;
            this.vx *= 0.94;
            this.vy *= 0.94;
            if (this.y < origin.y - 420) this.decay = 0.08;
        } else if (this.type === 'fire' || this.type === 'plasma') {
            this.size += 0.16;
            this.vy -= 0.19;
            this.vx *= 0.96;
            this.vy *= 0.96;
        } else {
            this.vy -= 0.09;
            this.vx *= 0.96;
            this.vy *= 0.96;
        }

        const dx = this.x - origin.x;
        const dy = origin.y - this.y;
        if (dy > 240 && (this.type === 'smoke' || this.type === 'fire')) {
            this.vx += dx * 0.015;
            if (Math.abs(dx) > 85) this.vy += 0.25;
            this.size += 0.06;
        }

        this.life -= this.decay;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        let r, g, b, alpha = this.life;

        if (this.type === 'coreJet') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 255; b = 250;
            alpha = this.life * 0.9;
        } else if (this.type === 'redPulse') {
            // INTENSE CRIMSON GLOW
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 20; b = 0;
            alpha = this.life * 1.0;
        } else if (this.type === 'plasma') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 200; b = 150;
        } else if (this.type === 'fire') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 110 * this.life; b = 20 * (this.life ** 3);
        } else {
            ctx.globalCompositeOperation = 'source-over';
            const val = this.type === 'dust' ? 45 : 75 * this.life;
            r = g = b = val;
            alpha = this.life * 0.75;
        }

        ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
        ctx.beginPath();
        const s = this.size;
        this.points.forEach((p, i) => {
            if (i === 0) ctx.moveTo(p.x * s, p.y * s);
            else ctx.lineTo(p.x * s, p.y * s);
        });
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

class Explosion {
    constructor() {
        this.particles = [];
        this.frame = 0;
        this.flash = 1.0;
        this.shake = 20;
        this.shockSize = 0;
    }

    update() {
        this.frame++;
        this.flash *= 0.88;
        this.shake *= 0.94;
        this.shockSize += 16;

        if (this.frame < 12) {
            for(let i=0; i<15; i++) {
                this.particles.push(new Particle(origin.x, origin.y, 'plasma'));
                this.particles.push(new Particle(origin.x, origin.y, 'dust', {
                    x: (Math.random() - 0.5) * 22, y: (Math.random() - 0.5) * 3
                }));
            }
        }

        if (this.frame > 4 && this.frame < 85) {
            if (this.frame % 2 === 0) {
                this.particles.push(new Particle(origin.x + (Math.random()-0.5)*8, origin.y, 'coreJet', {
                    x: (Math.random() - 0.5) * 1.5,
                    y: -10 - Math.random() * 5
                }));
            }
        }

        // --- CRIMSON PULSE ---
        if (this.frame === 95) {
            const pulseY = origin.y - 280;
            for(let i=0; i<250; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3.5 + Math.random() * 11; // 50% radius increase maintained
                this.particles.push(new Particle(origin.x, pulseY, 'redPulse', {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed
                }));
            }
            this.shake = 18; // Heavy jolt for the red pulse
        }

        if (this.frame > 10 && this.frame < 180) {
            for(let i=0; i<4; i++) {
                this.particles.push(new Particle(origin.x + (Math.random()-0.5)*20, origin.y - (this.frame * 1.5), 'fire'));
            }
            if (this.frame > 30) {
                const capY = Math.max(120, origin.y - (this.frame * 2.5));
                for(let i=0; i<6; i++) {
                    this.particles.push(new Particle(origin.x + (Math.random()-0.5)*60, capY, 'smoke'));
                }
            }
        }

        this.particles.forEach((p, i) => {
            p.update();
            if (p.life <= 0) this.particles.splice(i, 1);
        });
    }

    draw() {
        ctx.save();
        if (this.shake > 0.5) ctx.translate((Math.random()-0.5)*this.shake, (Math.random()-0.5)*this.shake);

        if (this.frame < 30) {
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.45 - this.frame/30})`;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.ellipse(origin.x, origin.y, this.shockSize, this.shockSize * 0.18, 0, 0, Math.PI * 2);
            ctx.stroke();
        }

        this.particles.sort((a,b) => {
            const types = { 'dust': 0, 'smoke': 1, 'fire': 2, 'redPulse': 3, 'coreJet': 4, 'plasma': 5 };
            return types[a.type] - types[b.type];
        });
        this.particles.forEach(p => p.draw(ctx));

        if (this.flash > 0.01) {
            ctx.fillStyle = `rgba(255,255,255,${this.flash})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        ctx.restore();
    }
}

let nuke = new Explosion();
function loop() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    nuke.update();
    nuke.draw();
    if (nuke.frame > 450 && nuke.particles.length === 0) nuke = new Explosion();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>

                this.size *= 0.90;
                this.decay = 0.04; // Rapid expiration on snap-back
            }
        }
        else if (this.type === 'coreJet') {
            this.vy -= 0.14;
            this.vx *= 0.94;
            this.vy *= 0.94;
            if (this.y < origin.y - 420) this.decay = 0.08;
        } else if (this.type === 'fire' || this.type === 'plasma') {
            this.size += 0.16;
            this.vy -= 0.19;
            this.vx *= 0.96;
            this.vy *= 0.96;
        } else {
            this.vy -= 0.09;
            this.vx *= 0.96;
            this.vy *= 0.96;
        }

        const dx = this.x - origin.x;
        const dy = origin.y - this.y;
        if (dy > 240 && (this.type === 'smoke' || this.type === 'fire')) {
            this.vx += dx * 0.015;
            if (Math.abs(dx) > 85) this.vy += 0.25;
            this.size += 0.06;
        }

        this.life -= this.decay;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        let r, g, b, alpha = this.life;

        if (this.type === 'coreJet') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 255; b = 250;
            alpha = this.life * 0.9;
        } else if (this.type === 'redPulse') {
            // INTENSE CRIMSON GLOW
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 20; b = 0;
            alpha = this.life * 1.0;
        } else if (this.type === 'plasma') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 200; b = 150;
        } else if (this.type === 'fire') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 110 * this.life; b = 20 * (this.life ** 3);
        } else {
            ctx.globalCompositeOperation = 'source-over';
            const val = this.type === 'dust' ? 45 : 75 * this.life;
            r = g = b = val;
            alpha = this.life * 0.75;
        }

        ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
        ctx.beginPath();
        const s = this.size;
        this.points.forEach((p, i) => {
            if (i === 0) ctx.moveTo(p.x * s, p.y * s);
            else ctx.lineTo(p.x * s, p.y * s);
        });
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

class Explosion {
    constructor() {
        this.particles = [];
        this.frame = 0;
        this.flash = 1.0;
        this.shake = 20;
        this.shockSize = 0;
    }

    update() {
        this.frame++;
        this.flash *= 0.88;
        this.shake *= 0.94;
        this.shockSize += 16;

        if (this.frame < 12) {
            for(let i=0; i<15; i++) {
                this.particles.push(new Particle(origin.x, origin.y, 'plasma'));
                this.particles.push(new Particle(origin.x, origin.y, 'dust', {
                    x: (Math.random() - 0.5) * 22, y: (Math.random() - 0.5) * 3
                }));
            }
        }

        if (this.frame > 4 && this.frame < 85) {
            if (this.frame % 2 === 0) {
                this.particles.push(new Particle(origin.x + (Math.random()-0.5)*8, origin.y, 'coreJet', {
                    x: (Math.random() - 0.5) * 1.5,
                    y: -10 - Math.random() * 5
                }));
            }
        }

        // --- CRIMSON PULSE ---
        if (this.frame === 95) {
            const pulseY = origin.y - 280;
            for(let i=0; i<250; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3.5 + Math.random() * 11; // 50% radius increase maintained
                this.particles.push(new Particle(origin.x, pulseY, 'redPulse', {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed
                }));
            }
            this.shake = 18; // Heavy jolt for the red pulse
        }

        if (this.frame > 10 && this.frame < 180) {
            for(let i=0; i<4; i++) {
                this.particles.push(new Particle(origin.x + (Math.random()-0.5)*20, origin.y - (this.frame * 1.5), 'fire'));
            }
            if (this.frame > 30) {
                const capY = Math.max(120, origin.y - (this.frame * 2.5));
                for(let i=0; i<6; i++) {
                    this.particles.push(new Particle(origin.x + (Math.random()-0.5)*60, capY, 'smoke'));
                }
            }
        }

        this.particles.forEach((p, i) => {
            p.update();
            if (p.life <= 0) this.particles.splice(i, 1);
        });
    }

    draw() {
        ctx.save();
        if (this.shake > 0.5) ctx.translate((Math.random()-0.5)*this.shake, (Math.random()-0.5)*this.shake);

        if (this.frame < 30) {
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.45 - this.frame/30})`;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.ellipse(origin.x, origin.y, this.shockSize, this.shockSize * 0.18, 0, 0, Math.PI * 2);
            ctx.stroke();
        }

        this.particles.sort((a,b) => {
            const types = { 'dust': 0, 'smoke': 1, 'fire': 2, 'redPulse': 3, 'coreJet': 4, 'plasma': 5 };
            return types[a.type] - types[b.type];
        });
        this.particles.forEach(p => p.draw(ctx));

        if (this.flash > 0.01) {
            ctx.fillStyle = `rgba(255,255,255,${this.flash})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        ctx.restore();
    }
}

let nuke = new Explosion();
function loop() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    nuke.update();
    nuke.draw();
    if (nuke.frame > 450 && nuke.particles.length === 0) nuke = new Explosion();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>

        if (this.life <= 0) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        let r, g, b, alpha = this.life;

        if (this.type === 'coreJet') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 255; b = 250;
            alpha = this.life * 0.9;
        } else if (this.type === 'redPulse') {
            // INTENSE CRIMSON GLOW
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 20; b = 0;
            alpha = this.life * 1.0;
        } else if (this.type === 'plasma') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 200; b = 150;
        } else if (this.type === 'fire') {
            ctx.globalCompositeOperation = 'lighter';
            r = 255; g = 110 * this.life; b = 20 * (this.life ** 3);
        } else {
            ctx.globalCompositeOperation = 'source-over';
            const val = this.type === 'dust' ? 45 : 75 * this.life;
            r = g = b = val;
            alpha = this.life * 0.75;
        }

        ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
        ctx.beginPath();
        const s = this.size;
        this.points.forEach((p, i) => {
            if (i === 0) ctx.moveTo(p.x * s, p.y * s);
            else ctx.lineTo(p.x * s, p.y * s);
        });
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

class Explosion {
    constructor() {
        this.particles = [];
        this.frame = 0;
        this.flash = 1.0;
        this.shake = 20;
        this.shockSize = 0;
    }

    update() {
        this.frame++;
        this.flash *= 0.88;
        this.shake *= 0.94;
        this.shockSize += 16;

        if (this.frame < 12) {
            for(let i=0; i<15; i++) {
                this.particles.push(new Particle(origin.x, origin.y, 'plasma'));
                this.particles.push(new Particle(origin.x, origin.y, 'dust', {
                    x: (Math.random() - 0.5) * 22, y: (Math.random() - 0.5) * 3
                }));
            }
        }

        if (this.frame > 4 && this.frame < 85) {
            if (this.frame % 2 === 0) {
                this.particles.push(new Particle(origin.x + (Math.random()-0.5)*8, origin.y, 'coreJet', {
                    x: (Math.random() - 0.5) * 1.5,
                    y: -10 - Math.random() * 5
                }));
            }
        }

        // --- CRIMSON PULSE ---
        if (this.frame === 95) {
            const pulseY = origin.y - 280;
            for(let i=0; i<250; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3.5 + Math.random() * 11; // 50% radius increase maintained
                this.particles.push(new Particle(origin.x, pulseY, 'redPulse', {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed
                }));
            }
            this.shake = 18; // Heavy jolt for the red pulse
        }

        if (this.frame > 10 && this.frame < 180) {
            for(let i=0; i<4; i++) {
                this.particles.push(new Particle(origin.x + (Math.random()-0.5)*20, origin.y - (this.frame * 1.5), 'fire'));
            }
            if (this.frame > 30) {
                const capY = Math.max(120, origin.y - (this.frame * 2.5));
                for(let i=0; i<6; i++) {
                    this.particles.push(new Particle(origin.x + (Math.random()-0.5)*60, capY, 'smoke'));
                }
            }
        }

        this.particles.forEach((p, i) => {
            p.update();
            if (p.life <= 0) this.particles.splice(i, 1);
        });
    }

    draw() {
        ctx.save();
        if (this.shake > 0.5) ctx.translate((Math.random()-0.5)*this.shake, (Math.random()-0.5)*this.shake);

        if (this.frame < 30) {
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.45 - this.frame/30})`;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.ellipse(origin.x, origin.y, this.shockSize, this.shockSize * 0.18, 0, 0, Math.PI * 2);
            ctx.stroke();
        }

        this.particles.sort((a,b) => {
            const types = { 'dust': 0, 'smoke': 1, 'fire': 2, 'redPulse': 3, 'coreJet': 4, 'plasma': 5 };
            return types[a.type] - types[b.type];
        });
        this.particles.forEach(p => p.draw(ctx));

        if (this.flash > 0.01) {
            ctx.fillStyle = `rgba(255,255,255,${this.flash})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        ctx.restore();
    }
}

let nuke = new Explosion();
function loop() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    nuke.update();
    nuke.draw();
    if (nuke.frame > 450 && nuke.particles.length === 0) nuke = new Explosion();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
