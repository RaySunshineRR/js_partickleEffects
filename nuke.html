<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Thermonuclear Simulation V3 - Revised</title>
    <style>
        body {
            background: #050505;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            box-shadow: 0 0 100px rgba(255, 50, 0, 0.1);
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.4);
            font-family: 'Courier New', monospace;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        SYSTEM: VORTEX_FLUID_APPROX<br>
        STATUS: AWAITING INPUT (CLICK)
    </div>
    <canvas id="simCanvas"></canvas>
<script>
/**
 * THERMONUCLEAR PHYSICS ENGINE V3 - REVISED
 * ----------------------------------------
 * Ionization implosion moved higher into the mushroom disk.
 * Fire jet (stem) now only extends a tiny bit past the mushroom cap.
 */
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W, H, scale;
let particles = [];
let frame = 0;
let state = 'idle';
let origin = { x: 0, y: 0 };
// --- CONFIGURATION ---
const CFG = {
    partCount: 800,
    drag: 0.96,
    thermalLift: 0.22,          // Reduced slightly to limit jet height
    vortexStrength: 0.03,
    coolingRate: 0.004,
    turbulence: 0.1,
    flashFrames: 10,
    maxHeight: 380,             // Slightly reduced cap height
    capFlatten: 0.6,
    ionFrame: 130,              // Slightly later trigger
    ionImplodeStart: 35,
    ionForce: 0.12,
    ionRadius: 1.5,
    stemMaxExtension: 0.15      // Stem only extends ~15% of cap height above cap
};
// --- COLOR MAP ---
function getHeatColor(temp, type, alpha) {
    if (type === 'shock') return `rgba(255, 255, 255, ${alpha})`;
    if (type === 'ring') return `rgba(220, 230, 255, ${alpha * 0.4})`;
    if (type === 'cap') return `rgba(180, 180, 180, ${alpha * 0.7})`;
    if (type === 'ion') return `rgba(255, 50, 50, ${alpha})`;
    if (type === 'ionsphere') return `rgba(255, 100, 50, ${alpha})`;

    if (temp > 0.9) return `rgba(200, 220, 255, ${alpha})`;
    if (temp > 0.7) return `rgba(255, 255, 180, ${alpha})`;
    if (temp > 0.5) return `rgba(255, 160, 20, ${alpha})`;
    if (temp > 0.25) return `rgba(180, 40, 10, ${alpha})`;
    if (temp > 0.1) return `rgba(60, 60, 60, ${alpha})`;
    return `rgba(20, 20, 20, ${alpha})`;
}
function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
    scale = Math.min(W, H) / 1200;
    origin = { x: W/2, y: H * 0.7 };
}
window.addEventListener('resize', resize);
resize();
// --- HELPERS ---
const rand = (min, max) => Math.random() * (max - min) + min;
// --- PARTICLE CLASS ---
class Particle {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        
        this.vx = 0;
        this.vy = 0;
        
        this.size = rand(5, 15) * scale;
        this.temp = 1.0;
        this.life = 1.0;
        this.decay = rand(0.9, 1.1) * CFG.coolingRate;
        this.localFrame = 0;
        
        this.initPhysics();
    }
    initPhysics() {
        const speed = rand(1, 6) * scale;
        const angle = rand(0, Math.PI * 2);
        if (this.type === 'core') {
            this.vx = Math.cos(angle) * speed * 2;
            this.vy = Math.sin(angle) * speed * 2 - (3 * scale);
            this.decay *= 0.8;
        } else if (this.type === 'debris') {
            this.vx = Math.cos(angle) * speed * 1.5;
            this.vy = Math.random() * -3 * scale;
            this.temp = 0.3;
            this.size = rand(3, 8) * scale;
            this.decay *= 2;
        } else if (this.type === 'spark') {
            this.vx = Math.cos(angle) * speed * 3;
            this.vy = Math.sin(angle) * speed * 3;
            this.size = rand(1, 3) * scale;
            this.decay = 0.06;
        } else if (this.type === 'ring') {
            this.vx = 0;
            this.vy = 0;
            this.temp = 0;
            this.size = rand(15, 30) * scale;
            this.life = 0.4;
            this.decay = 0.025;
        } else if (this.type === 'cap') {
            this.vx = Math.cos(angle) * speed * 1.2;
            this.vy = Math.sin(angle) * speed * 0.5;
            this.temp = 0.4;
            this.size = rand(8, 20) * scale;
            this.decay *= 1.2;
        } else if (this.type === 'stem') {
            this.vy = -6.5 * scale;          // Slightly slower initial velocity
            this.vx = (Math.random()-0.5) * 1.5 * scale;
            this.temp = 0.8;
        } else if (this.type === 'ion') {
            this.vx = Math.cos(angle) * rand(6, 12) * scale;
            this.vy = Math.sin(angle) * rand(6, 12) * scale;
            this.temp = 0.3;
            this.size = rand(3, 6) * scale;
            this.decay = 0.005;
        } else if (this.type === 'ionsphere') {
            this.vx = 0;
            this.vy = 0;
            this.temp = 0.6;
            this.size = 22 * scale;           // Slightly larger sphere
            this.decay = 0.003;
        }
    }
    update(capY, capRadius) {
        this.localFrame++;
        
        this.vx *= CFG.drag;
        this.vy *= CFG.drag;
        
        if (this.type !== 'debris' && this.type !== 'ring' && this.type !== 'ionsphere') {
            this.vy -= this.temp * CFG.thermalLift * scale;
        }
        
        // Cap height limit (affects all but stem)
        if (this.y < origin.y - CFG.maxHeight * scale && this.type !== 'stem') {
            this.vy = Math.max(this.vy, 0);
        }
        
        // Vortex for core, stem, cap
        if (this.type === 'core' || this.type === 'stem' || this.type === 'cap') {
            const dy = this.y - capY;
            const dx = this.x - origin.x;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < capRadius * 1.2) {
                const force = CFG.vortexStrength * this.temp * scale;
                this.vx += (dx / dist) * force * 1.5;
                this.vy += (dy / dist) * force * CFG.capFlatten;
                if (dy > 0 && Math.abs(dx) < capRadius) {
                    this.vx -= (dx * 0.015) * scale;
                }
                if (Math.abs(dx) > capRadius * 0.6) {
                    this.vy += 0.15 * scale;
                }
            }
            // Limit stem extension: strong downward force when too high above cap
            if (this.type === 'stem' && this.y < capY - (CFG.maxHeight * CFG.stemMaxExtension * scale)) {
                this.vy += 0.4 * scale;  // Pull back down
                this.vy = Math.min(this.vy, 0); // Prevent further rise
            }
        }
        
        // Ground suction
        if (this.y > origin.y - (80 * scale) && this.type !== 'ring' && this.type !== 'ionsphere') {
            const dx = origin.x - this.x;
            this.vx += dx * 0.004;
            this.vy -= 0.08 * scale;
        }
        
        this.vx += (Math.random() - 0.5) * CFG.turbulence * scale;
        
        if (this.y < origin.y - 80) {
            this.size += 0.05 * scale;
        }
        
        // Ion implosion - centered higher (at capY)
        if (this.type === 'ion' && this.localFrame > CFG.ionImplodeStart) {
            const dx = origin.x - this.x;
            const dy = capY - this.y;  // Implode toward current cap center height
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 0) {
                const force = CFG.ionForce * scale;
                this.vx += (dx / dist) * force;
                this.vy += (dy / dist) * force;
            }
        }
        
        this.temp -= this.decay;
        if (this.temp < 0) this.temp = 0;
        this.life -= this.decay;
        
        this.x += this.vx;
        this.y += this.vy;
    }
    draw(ctx) {
        if (this.life <= 0) return;
        ctx.beginPath();
        
        let alpha = this.life;
        if (this.type === 'core') alpha *= (this.temp > 0.5 ? 0.5 : 0.7);
        if (this.type === 'ring') alpha = this.life * 0.25;
        if (this.type === 'cap') alpha *= 0.8;
        if (this.type === 'ion') alpha *= 0.6;
        if (this.type === 'ionsphere') alpha *= 0.4;
        
        const drawSize = this.size;
        const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, drawSize);
        
        const color = getHeatColor(this.temp, this.type, 1);
        const colorTransparent = getHeatColor(this.temp, this.type, 0);
        grad.addColorStop(0, color);
        grad.addColorStop(1, colorTransparent);
        ctx.fillStyle = grad;
        ctx.arc(this.x, this.y, drawSize, 0, Math.PI*2);
        ctx.fill();
    }
}
// --- SHOCKWAVE CLASS ---
class Shockwave {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.r = 0;
        this.speed = 30 * scale;
        this.life = 1.0;
    }
    update() {
        this.r += this.speed;
        this.speed *= 0.94;
        this.life -= 0.018;
    }
    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(1, 0.4);
        
        ctx.beginPath();
        ctx.arc(0, 0, this.r, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${this.life * 0.4})`;
        ctx.lineWidth = 30 * scale * this.life;
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(0, 0, this.r * 0.8, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${this.life * 0.15})`;
        ctx.lineWidth = 8 * scale * this.life;
        ctx.stroke();
        
        ctx.restore();
    }
}
// --- CONTROLLER ---
let shockwaves = [];
let ionizationTriggered = false;
function detonate(x, y) {
    particles = [];
    shockwaves = [];
    frame = 0;
    origin.x = x;
    origin.y = y;
    state = 'detonation';
    ionizationTriggered = false;
    
    shockwaves.push(new Shockwave(x, y));
    
    for (let i = 0; i < CFG.partCount * 0.3; i++) {
        particles.push(new Particle(x, y, 'core'));
    }
    
    for (let i = 0; i < CFG.partCount * 0.15; i++) {
        particles.push(new Particle(x, y, 'debris'));
    }
    
    for (let i = 0; i < 30; i++) {
        particles.push(new Particle(x, y, 'spark'));
    }
    
    for (let i = 0; i < CFG.partCount * 0.25; i++) {
        particles.push(new Particle(x, y - 50 * scale, 'cap'));
    }
}
function loop() {
    requestAnimationFrame(loop);
    
    if (state === 'detonation' && frame < CFG.flashFrames) {
        const flashIntensity = 1 - (frame / CFG.flashFrames);
        ctx.fillStyle = `rgb(${255*flashIntensity}, ${240*flashIntensity}, ${220*flashIntensity})`;
        ctx.fillRect(0, 0, W, H);
        
        const shake = 20 * scale * flashIntensity;
        ctx.save();
        ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
    } else {
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, W, H);
    }
    frame++;
    
    const currentCapY = Math.max(origin.y - (Math.min(frame * 2.5, CFG.maxHeight) * scale), origin.y - CFG.maxHeight * scale);
    const currentCapRadius = (30 + Math.min(frame * 1.5, 200)) * scale;
    
    // Stem emission - shorter duration + controlled height
    if (frame < 140) {
        const emitCount = frame < 70 ? 4 : 1;
        for (let i = 0; i < emitCount; i++) {
            particles.push(new Particle(origin.x + (Math.random()-0.5)*30*scale, origin.y, 'stem'));
        }
    }
    
    if (frame > 30 && frame < 100 && frame % 12 === 0) {
        const ringCount = 25;
        for (let i = 0; i < ringCount; i++) {
            const angle = (i/ringCount) * Math.PI*2;
            const r = currentCapRadius * 1.1;
            const px = origin.x + Math.cos(angle) * r;
            const py = currentCapY + Math.sin(angle) * (r * CFG.capFlatten);
            particles.push(new Particle(px, py, 'ring'));
        }
    }
    
    if (frame > 110 && frame < 180 && frame % 15 === 0) {
        const ringCount = 20;
        for (let i = 0; i < ringCount; i++) {
            const angle = (i/ringCount) * Math.PI*2;
            const r = currentCapRadius * 0.8;
            const px = origin.x + Math.cos(angle) * r;
            const py = currentCapY + 20 * scale + Math.sin(angle) * (r * CFG.capFlatten);
            particles.push(new Particle(px, py, 'ring'));
        }
    }
    
    // Ionization blast higher in the cap
    if (!ionizationTriggered && frame === CFG.ionFrame) {
        ionizationTriggered = true;
        const sphereY = currentCapY - 40 * scale;  // Position sphere noticeably above cap center
        const sphere = new Particle(origin.x, sphereY, 'ionsphere');
        particles.push(sphere);
        
        const ionCount = 100;
        for (let i = 0; i < ionCount; i++) {
            particles.push(new Particle(origin.x, sphereY, 'ion'));
        }
    }
    
    shockwaves.forEach((s, i) => {
        s.update();
        s.draw(ctx);
        if (s.life <= 0) shockwaves.splice(i, 1);
    });
    
    particles.sort((a, b) => a.temp - b.temp);
    
    particles.forEach((p, i) => {
        p.update(currentCapY, currentCapRadius);
        
        if (p.temp > 0.4) ctx.globalCompositeOperation = 'lighter';
        else ctx.globalCompositeOperation = 'source-over';
        
        p.draw(ctx);
        if (p.life <= 0 || p.size > 300) {
            particles.splice(i, 1);
        }
    });
    
    ctx.globalCompositeOperation = 'source-over';
    if (frame < CFG.flashFrames) ctx.restore();
    
    if (particles.length === 0 && frame > 100) {
        setTimeout(() => detonate(W/2, H*0.7), 500);
    }
}
// Input Handling
canvas.addEventListener('mousedown', (e) => detonate(e.clientX, e.clientY));
// Initial Start
detonate(window.innerWidth/2, window.innerHeight * 0.7);
loop();
</script>
</body>
</html>
